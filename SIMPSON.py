# -*- coding: utf-8 -*-
"""Damped spring-mass oscillator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OLpTPevX0DVz9xjCEOPc5A3jXUqI3WLB

*Simpson’s rule* *
"""

#@title Define funciones $\int \limits_{0}^{1} \frac{1}{1+x^{2}} \cdot dx = \frac{\pi}{4}$
import numpy as np
import matplotlib.pyplot as plt

#Define la función
def f(x):
  return 1.0/(1.0+x**2)

#Regla del trapecio compuesto
def trapecio_compuesto(a,b,n):
  h = (b-a)/n #paso
  x = np.linspace(a,b,n+1)
  y = f(x)
  return (h/2)*(y[0] + 2*np.sum(y[1:-1])+ y[-1]) #Regla del trapecio compuesto

#Regla de Simpson Compuesta
def simpson_compuesto(a,b,n):
  if n %2 !=0:
    n +=1 #para poder dividir el intervalo en segmentos pares
  h = (b-a)/n
  x = np.linspace(a,b,n+1)
  y = f(x)
  return (h/3) * (y[0] + 4*np.sum(y[1:-1:2]) + 2*np.sum(y[2:-2:2]) + y[-1]) # Regla de Simpson Compuesta



#@title Intervalo y Aproximación usando $\frac{\pi}{4}$
a,b = 0,1
n_valores = np.arange(1,101)

#Aproximación usando $I=\pi/4$, pero $ \pi = 4 * I$ en los dos métodos
I_trap = np.array([trapecio_compuesto(a, b, n) for n in n_valores])
I_simpson = np.array([simpson_compuesto(a, b, n) for n in n_valores])

pi_trapecio = 4 * I_trap
pi_simpson = 4 * I_simpson

#Valores reales de Comparación
I_real = np.pi/4
pi_real = np.pi

#Imprime alguno valores de I (≈π/4) y π aproximado
print("Ejemplos (I ≈ π/4)  y  (π≈4·I):")
for i in [1,2,5,10,50,100]:
    print(f"n={i:3d} | I_trapecio={I_trap[i-1]:.10f} | 4·I_trapecio={pi_trapecio[i-1]:.10f}  ||  I_simpson={I_simpson[i-1]:.10f} | 4·I_simpson={pi_simpson[i-1]:.10f}")